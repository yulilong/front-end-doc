[[TOC]]

[TOC]

# ä»£ç ç¤ºä¾‹1

## 1. æ‹¦æˆªaé“¾æ¥å˜æˆJSä»£ç å¤„ç†

**Vue3 ç»„ä»¶ä¸­ç”¨ `v-html` æ¸²æŸ“å¯Œæ–‡æœ¬**ï¼Œé‡Œé¢å¯èƒ½æœ‰ `<a href="xxx">` é“¾æ¥ã€‚é—®é¢˜æ˜¯ï¼š

- `v-html` æ¸²æŸ“çš„å†…å®¹æ˜¯ã€Œé™æ€ HTMLã€ï¼ŒVue ä¸ä¼šå¸®ä½ è‡ªåŠ¨ç»‘å®šäº‹ä»¶ã€‚
- æ‰€ä»¥ç‚¹ `<a>` é»˜è®¤å°±æ˜¯ç›´æ¥è·³è½¬ã€‚

ğŸ‘‰ è¦è§£å†³ï¼šéœ€è¦åœ¨ç»„ä»¶é‡Œç”¨ **äº‹ä»¶ä»£ç†** æˆ–è€… **æ‰‹åŠ¨ç»‘å®šäº‹ä»¶** æ¥æ‹¦æˆª `<a>` ç‚¹å‡»ï¼Œå†è°ƒç”¨ Vue æ–¹æ³•ã€‚` <a> `é“¾æ¥é‡Œå¯èƒ½æœ‰å‚æ•°ï¼ˆæ¯”å¦‚ query stringï¼‰ï¼Œç‚¹å‡»æ—¶æ‹¦æˆªï¼Œè§£æå‚æ•°ï¼Œç”¨å‚æ•°åšé€»è¾‘å¤„ç†ã€‚

```vue
<template>
  <div ref="contentRef" v-html="htmlContent"></div>
</template>

<script setup lang="ts">
import { ref, onMounted, onBeforeUnmount } from 'vue'

const htmlContent = `
  <p>ç‚¹æˆ‘çœ‹çœ‹æ•ˆæœï¼š
    <a href="https://example.com/page?userId=123&action=edit">è‡ªå®šä¹‰è·³è½¬</a>
  </p>
`
const contentRef = ref<HTMLElement | null>(null)

function handleLinkClick(e: Event) {
  const target = e.target as HTMLElement
  if (target.tagName.toLowerCase() === 'a') {
    e.preventDefault() // é˜»æ­¢é»˜è®¤è·³è½¬
    const href = (target as HTMLAnchorElement).href
    if (href) {
      try {
        // ç”¨ URL API è§£æå‚æ•°
        const url = new URL(href)
        const userId = url.searchParams.get('userId')
        const action = url.searchParams.get('action')

        console.log('æ‹¦æˆªåˆ°é“¾æ¥:', href)
        console.log('å‚æ•° userId:', userId)
        console.log('å‚æ•° action:', action)

        // TODO: è¿™é‡Œå†™è‡ªå®šä¹‰å¤„ç†é€»è¾‘
        alert(`å¤„ç†å‚æ•°ï¼šuserId=${userId}, action=${action}`)
      } catch (err) {
        console.error('URL è§£æå¤±è´¥:', err)
      }
    }
  }
}

onMounted(() => {
  contentRef.value?.addEventListener('click', handleLinkClick)
})

onBeforeUnmount(() => {
  contentRef.value?.removeEventListener('click', handleLinkClick)
})
</script>
```



## 2. å‚ç›´é«˜äº®è½®æ’­åˆ‡æ¢æ•ˆæœ

æ•ˆæœï¼š

![](./img/20-01.png)



çˆ¶ç»„ä»¶ä»£ç ï¼š

```vue
<template>
  <el-container style="padding:24px;">
    <el-header style="display:flex;align-items:center;gap:12px;">
      <el-input v-model="title" placeholder="æ ‡é¢˜ï¼ˆä»…ç¤ºä¾‹ï¼‰" style="width:240px" />
      <el-button @click="resetItems">é‡ç½®æ•°æ®</el-button>
      <el-button type="primary" @click="addItem">è¿½åŠ ä¸€é¡¹</el-button>
      <el-button type="danger" @click="removeItem" :disabled="items.length===0">åˆ é™¤æœ«é¡¹</el-button>
      <div style="margin-left:auto;color:#cfe0ff">å½“å‰ç´¢å¼•: {{ currentIndex }}</div>
    </el-header>

    <el-main style="display:flex;justify-content:center;align-items:flex-start;padding-top:20px;">
      <!-- æŠŠæ•°ç»„ä¼ ç»™å­ç»„ä»¶ï¼Œå¹¶ç›‘å¬äº‹ä»¶ -->
      <SeamlessLoopHighlight
        :items="items"
        @prev="onPrev"
        @next="onNext"
        @item-click="onItemClick"
      />
    </el-main>
  </el-container>
</template>

<script setup lang="ts">
import { ref } from 'vue';
import { ElMessage } from 'element-plus';
import SeamlessLoopHighlight from './component/SeamlessLoopHighlight.vue'; // æ ¹æ®ä½ é¡¹ç›®è·¯å¾„è°ƒæ•´

const title = ref('ç¤ºä¾‹ï¼šæ»šåŠ¨é«˜äº®åˆ—è¡¨');

const initial = [
  {name: 'è™šæ‹Ÿå†…å­˜1', value: 1},
  {name: 'è™šæ‹ŸCPU', value: 2},
  {name: 'è™šæ‹Ÿå­˜å‚¨', value: 3},
  {name: 'è™šæ‹ŸIP', value: 4}, 
  {name: 'è™šæ‹Ÿç½‘ç»œ', value: 5}, 
  {name: 'è™šæ‹Ÿç£ç›˜', value: 6}, 
  {name: 'è™šæ‹ŸGPU', value: 7}, 
  {name: 'è™šæ‹Ÿå¸¦å®½', value: 8}, 
  {name: 'è™šæ‹Ÿå®‰å…¨ç»„', value: 9}, 
  {name: 'è™šæ‹Ÿäº¤æ¢æœº', value: 10}, 
  {name: 'è™šæ‹Ÿé˜²ç«å¢™', value: 11}, 
  {name: 'è™šæ‹Ÿç½‘å…³', value: 12}, 
  {name: 'è™šæ‹Ÿè´Ÿè½½å‡è¡¡', value: 13}, 
  {name: 'è™šæ‹Ÿé•œåƒ11', value: 14}
] ;
type Item = { name: string; value: number };
const items = ref<Item[]>([...initial]);

// å¦‚æœä½ æƒ³ä¿æŒçˆ¶ç»„ä»¶é‡Œçš„ currentIndexï¼ˆå±•ç¤ºç”¨ï¼‰
const currentIndex = ref(0);

function onPrev(a) {
  // å½“å­ç»„ä»¶å‘å‡º prev äº‹ä»¶æ—¶è§¦å‘ï¼ˆå‘ä¸Šï¼‰
  // è¿™é‡Œæˆ‘ä»¬ä»…æ¼”ç¤ºå¦‚ä½•æ¥æ”¶äº‹ä»¶å¹¶æ›´æ–°çˆ¶çŠ¶æ€
  currentIndex.value = (currentIndex.value - 1 + items.value.length) % (items.value.length || 1);
  // ElMessage({ message: 'å‘ä¸Šç¿»ä¸€é¡¹', type: 'info', duration: 800 });
  ElMessage({ message: a, type: 'info', duration: 800 });
}

function onNext() {
  currentIndex.value = (currentIndex.value + 1) % (items.value.length || 1);
  ElMessage({ message: 'å‘ä¸‹ç¿»ä¸€é¡¹', type: 'success', duration: 800 });
}

function onItemClick(payload: { item: string; index: number }) {
  // payload æ¥è‡ªå­ç»„ä»¶ emit('item-click', { item, index })
  ElMessage({
    message: `ç‚¹å‡»é¡¹ï¼š${payload.item}ï¼ˆç´¢å¼• ${payload.index}ï¼‰`,
    type: 'warning'
  });
  console.log('wozhixing ');
}

// ç¤ºèŒƒï¼šçˆ¶ç»„ä»¶ä¿®æ”¹ itemsï¼ˆå­ç»„ä»¶ä¼šå“åº” watchï¼‰
function addItem() {
  items.value.push({ name: `æ–°é¡¹${items.value.length + 1}`, value: items.value.length + 1 });
}

function removeItem() {
  items.value.pop();
  if (currentIndex.value >= items.value.length) currentIndex.value = Math.max(0, items.value.length - 1);
}

function resetItems() {
  items.value = [...initial];
  currentIndex.value = 0;
}
</script>

<style scoped>
/* ä»…ä½œé¡µé¢å¸ƒå±€ç¤ºä¾‹ï¼Œå¯æŒ‰éœ€åˆ æ”¹ */
.el-header { background: transparent; border-bottom: none; padding: 12px 0; }
.el-main { min-height: 360px; }
</style>
```

å­ç»„ä»¶ï¼š

```vue
<template>
  <div class="wrap">
    <el-button class="arrow" type="text" @click="onUp">âˆ§</el-button>

    <div class="viewport">
      <div ref="listEl" class="list" :style="listStyle">
        <!-- æ¸²æŸ“ VISIBLE+2 ä¸ªå ä½èŠ‚ç‚¹ -->
        <div v-for="(n, i) in nodesCount" :key="i" class="item" @click="onItemClick(i)">
          {{ visibleTexts[i]?.name }}{{ visibleTexts[i]?.value }}
        </div>
      </div>
    </div>

    <el-button class="arrow" type="text" @click="onDown">âˆ¨</el-button>
  </div>
</template>

<script lang="ts" setup>
import { ref, watch, computed, onMounted, nextTick, onBeforeUnmount } from 'vue';
import type { PropType } from 'vue';

// Props + Emits
type Item = { name: string; value: number };
const props = defineProps({
  items: { type: Array as PropType<Item[]>, default: () => [] }
});
const emit = defineEmits(['prev', 'next', 'item-click']);

// å¸¸é‡
const ITEM_H = 60;
const VIEW_H = 300;
const VISIBLE = 5;
const CENTER = Math.floor(VISIBLE / 2);
const ANIM_MS = 360;

// DOM refs
const listEl = ref<HTMLElement | null>(null);

// æœ¬åœ°çŠ¶æ€
const currentIndex = ref(0);
const isAnimating = ref(false);

// ä¸ºäº†å®ç°è·ŸåŸç”Ÿå®ç°ä¸€è‡´ï¼Œä¿æŒ VISIBLE+2 ä¸ªèŠ‚ç‚¹
const nodesCount = VISIBLE + 2;

// è®¡ç®—å ä½èŠ‚ç‚¹æ˜¾ç¤ºæ–‡æœ¬ï¼ˆæ ¹æ® currentIndex å’Œ props.itemsï¼‰
const visibleTexts = computed(() => {
  const arr: (Item | null)[] = [];
  const n = props.items.length;
  for (let i = 0; i < nodesCount; i++) {
    const offset = i - (CENTER + 1);
    const idx = n ? ((currentIndex.value + offset) % n + n) % n : -1;
    arr.push(idx >= 0 ? props.items[idx] : null);
  }
  return arr;
});

// list çš„ transform æ ·å¼ï¼ˆå†…è” styleï¼‰ï¼Œç”¨äºåŠ¨ç”»
const baseTranslate = VIEW_H / 2 - ((CENTER + 1) * ITEM_H + ITEM_H / 2);
const translateY = ref(baseTranslate);
const transitioning = ref(false);

const listStyle = computed(() => ({
  transform: `translateY(${translateY.value}px)`,
  transition: transitioning.value ? `transform ${ANIM_MS}ms cubic-bezier(.2,.9,.2,1)` : 'none'
}));

// æ›´æ–°é«˜äº®ï¼ˆå­—ä½“å¤§å° / é¢œè‰² / opacityï¼‰
function updateHighlightStyles() {
  if (!listEl.value) return;
  const children = Array.from(listEl.value.children) as HTMLElement[];
  children.forEach((el, i) => {
    const offset = i - (CENTER + 1);
    const t = Math.max(0, 1 - Math.abs(offset));
    const fontSize = 20 + t * (28 - 20);
    const opacity = 0.6 + t * (1 - 0.6);
    const colorVal = Math.floor(153 + t * (255 - 153));
    el.style.fontSize = `${fontSize}px`;
    el.style.opacity = String(opacity);
    el.style.color = `rgb(${colorVal},${colorVal},${colorVal})`;
  });
}

// è®¾ç½® transformï¼ˆå¸¦/ä¸å¸¦åŠ¨ç”»ï¼‰
function setTransform(y: number, animate = true) {
  transitioning.value = animate;
  translateY.value = y;
}

// ç§»åŠ¨å‡½æ•°ï¼ˆstep = +1 æˆ– -1ï¼‰
// è¿”å›ä¸€ä¸ª Promiseï¼Œåœ¨åŠ¨ç”»ç»“æŸæ—¶ resolveï¼Œä¾¿äºè°ƒç”¨æ–¹å¾—åˆ°æœ€æ–°é«˜äº®é¡¹
function move(step: number): Promise<void> {
  return new Promise((resolve) => {
    if (isAnimating.value) return resolve();
    if (!props.items.length) return resolve();

    isAnimating.value = true;
    currentIndex.value = ((currentIndex.value + step) % props.items.length + props.items.length) % props.items.length;

    console.log('move currentIndex.value: ', currentIndex.value );
    // å…ˆæ›´æ–°æ–‡æœ¬å’Œæ ·å¼ï¼ˆcomputed visibleTexts ä¼šå˜åŒ–ï¼‰
    nextTick(() => {
      updateHighlightStyles();

      // åšåŠ¨ç”»ï¼šç§»åŠ¨ step é«˜åº¦
      setTransform(baseTranslate - step * ITEM_H, true);

      const onEnd = () => {
        if (!listEl.value) return;
        listEl.value.removeEventListener('transitionend', onEnd);

        // æ¢å¤åˆ° baseTranslateï¼ˆæ— åŠ¨ç”»ï¼‰
        setTransform(baseTranslate, false);
        console.log('æˆ‘æ‰§è¡Œäº†');

        // ç­‰ä¸€å¸§å†è§£é™¤ anim æ ‡å¿—å¹¶ resolve
        requestAnimationFrame(() => {
          isAnimating.value = false;
          resolve();
        });
      };

      if (listEl.value) {
        listEl.value.addEventListener('transitionend', onEnd);
        console.log('æ·»åŠ ç›‘å¬');
      } else {
        // å…œåº•
        setTimeout(() => { isAnimating.value = false; setTransform(baseTranslate, false); resolve(); }, ANIM_MS + 30);
      }
    });
  });
}

// æŒ‰é’®äº‹ä»¶ï¼ˆåŒæ—¶é€šçŸ¥çˆ¶ç»„ä»¶ï¼‰
async function onDown() {
  await move(1);
  // å°†å½“å‰é«˜äº®é¡¹ï¼ˆå½“å‰ currentIndex å¯¹åº”çš„ itemï¼‰ä¼ å›çˆ¶ç»„ä»¶
  const item = props.items[currentIndex.value];
  emit('next', item);
}
async function onUp() {
  await move(-1);
  const item = props.items[currentIndex.value];
  emit('prev', item);
}

// é¡¹ç›®ç‚¹å‡»
function onItemClick(nodeIndex: number) {
  // è®¡ç®—çœŸå®ç´¢å¼•
  const n = props.items.length;
  if (!n) return;
  const offset = nodeIndex - (CENTER + 1);
  const idx = ((currentIndex.value + offset) % n + n) % n;
  const item = props.items[idx];
  emit('item-click', item);
}

// é”®ç›˜ç›‘å¬
function onKeydown(e: KeyboardEvent) {
  if (e.key === 'ArrowDown') onDown();
  if (e.key === 'ArrowUp') onUp();
}

onMounted(() => {
  // åˆå§‹åŒ– transform ä¸é«˜äº®
  setTransform(baseTranslate, false);
  nextTick(() => updateHighlightStyles());
  window.addEventListener('keydown', onKeydown);
});

onBeforeUnmount(() => {
  window.removeEventListener('keydown', onKeydown);
});

// å½“çˆ¶ç»„ä»¶ä¿®æ”¹ items æ—¶ï¼Œé‡ç½® currentIndex ä¿è¯ä¸è¶Šç•Œå¹¶æ›´æ–°æ˜¾ç¤º
watch(() => props.items, (newVal) => {
  if (!newVal || newVal.length === 0) return;
  currentIndex.value = currentIndex.value % newVal.length;
  nextTick(() => updateHighlightStyles());
});
</script>

<style lang="scss" scoped>
:root{
  --bg:#1f2b40;
}
.wrap{
  background-color: #1f2b40;
  text-align:center;
  user-select:none;
  display:flex;
  flex-direction:column;
  align-items:center;
}
.arrow{
  font-size:40px;
  color:#dfe7f6;
  cursor:pointer;
  margin:10px 0;
  -webkit-tap-highlight-color:transparent;
}
.viewport{
  width:320px;
  height:300px;
  overflow:hidden;
  margin:8px auto;
  position:relative;
}
.list{
  display:flex;
  flex-direction:column;
  align-items:center;
  will-change: transform;
}
.item{
  height:60px;
  line-height:60px;
  width:100%;
  text-align:center;
  font-size:20px;
  opacity:0.6;
  color:rgb(153,153,153);
  box-sizing:border-box;
  user-select:none;
  cursor:pointer;
  // display:flex;
  // justify-content:space-between;
  // padding: 0 20px;
  transition: font-size 0.36s cubic-bezier(.2,.9,.2,1),
              color 0.36s cubic-bezier(.2,.9,.2,1),
              opacity 0.36s cubic-bezier(.2,.9,.2,1);
}
// .item .name{
//   flex:1;
//   text-align:left;
// }
// .item .value{
//   width:48px;
//   text-align:right;
// }
</style>
```

